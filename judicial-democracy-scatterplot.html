<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Judicial Constraints vs Democracy - 3D Chart</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.6.5/dist/three-spritetext.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f9fafb;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 24px;
        }
        .chart-container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        #chart {
            width: 100%;
            height: 600px;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 6px;
            padding: 12px;
            font-size: 14px;
            pointer-events: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            border: 1px solid #ddd;
            transition: opacity 0.2s;
            max-width: 250px;
            z-index: 1000;
        }
        .legend {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            font-size: 14px;
        }
        .legend-item {
            margin: 0 10px;
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 5px;
            border-radius: 3px;
        }
        .data-table {
            margin-top: 30px;
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            background: white;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .data-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #e9ecef;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        .data-table th:hover {
            background: #e9ecef;
        }
        .data-table th::after {
            content: "↕";
            position: absolute;
            right: 8px;
            opacity: 0.3;
        }
        .data-table th.asc::after {
            content: "↑";
            opacity: 1;
        }
        .data-table th.desc::after {
            content: "↓";
            opacity: 1;
        }
        .data-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            color: #666;
        }
        .data-table tr:hover {
            background-color: #f8f9fa;
        }
        .data-table tr.israel {
            background-color: #fff9e6;
        }
        .data-table tr.israel:hover {
            background-color: #fff3cd;
        }
        .sources {
            margin-top: 20px;
            font-size: 12px;
            color: #666;
            text-align: center;
            line-height: 1.5;
        }
        .sources a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s;
        }
        .sources a:hover {
            color: #2980b9;
            text-decoration: underline;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            background: #f0f7fa;
            padding: 10px;
            border-radius: 6px;
            min-width: 250px;
        }
        .control-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        .checkbox-row {
            display: flex;
            margin: 3px 0;
            align-items: center;
        }
        .checkbox-row input {
            margin-right: 8px;
        }
        .checkbox-row label {
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <h1>Judicial Constraints vs Democracy Level with Institutional Mechanisms</h1>
        <div class="controls">
            <div class="control-group">
                <div class="control-title">Institutional Mechanisms</div>
                <div class="checkbox-row">
                    <input type="checkbox" id="judicial_constraints" checked>
                    <label for="judicial_constraints">Judicial Constraints</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="legislative_constraints" checked>
                    <label for="legislative_constraints">Legislative Constraints</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="accountability_index" checked>
                    <label for="accountability_index">Accountability Index</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="high_court_independence" checked>
                    <label for="high_court_independence">High Court Independence</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="federalism_index" checked>
                    <label for="federalism_index">Federalism Index</label>
                </div>
            </div>
        </div>
        <div id="chart"></div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #e41a1c;"></div>
                <span>Judicial Constraints</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #377eb8;"></div>
                <span>Legislative Constraints</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4daf4a;"></div>
                <span>Accountability Index</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #984ea3;"></div>
                <span>High Court Independence</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff7f00;"></div>
                <span>Federalism Index</span>
            </div>
        </div>
        <div class="sources">
            Data sources: <a href="https://www.wikiwand.com/en/articles/The_Economist_Democracy_Index" target="_blank">Economist Intelligence Unit</a>, 
            <a href="https://ourworldindata.org/grapher/judicial-constraints-on-the-executive-index" target="_blank">Our World in Data</a>
        </div>
        <div id="data-table"></div>
    </div>

    <script>
        // Country name mapping to handle differences between the datasets
        const countryNameMapping = {
            // Map country names that differ between the two datasets
            "Czechia": "Czech Republic",
            "Cote d'Ivoire": "Côte d'Ivoire",
            "East Timor": "Timor-Leste",
            "Laos": "Lao PDR",
            "South Korea": "Korea, Rep.",
            "North Korea": "Korea, Dem. Rep.",
            "Eswatini": "Eswatini",
            "Congo": "Congo, Rep.",
            "Democratic Republic of Congo": "Congo, Dem. Rep.",
            "Cape Verde": "Cape Verde",
            "Turkey": "Türkiye",
            "Sao Tome and Principe": "São Tomé and Principe"
        };

        // Function to load and process the data
        async function loadData() {
            try {
                console.log("Starting to load CSV files...");
                
                // Log the files we're trying to load
                console.log("Attempting to load democracy data from:", "Untitled spreadsheet - Sheet2 (1).csv");
                console.log("Attempting to load judicial data from:", "judicial-constraints-on-the-executive-index.csv");
                
                // Load both CSV files
                const [democracyData, judicialData] = await Promise.all([
                    d3.csv("Untitled spreadsheet - Sheet2 (1).csv")
                        .catch(error => {
                            console.error("Error loading democracy data:", error);
                            document.getElementById("chart").innerHTML = 
                                "<p>Error loading democracy data from 'Untitled spreadsheet - Sheet2 (1).csv'. " +
                                "Please make sure the file exists in the same directory.</p>";
                            return [];
                        }),
                    d3.csv("judicial-constraints-on-the-executive-index.csv")
                        .catch(error => {
                            console.error("Error loading judicial data:", error);
                            document.getElementById("chart").innerHTML = 
                                "<p>Error loading judicial constraints data from 'judicial-constraints-on-the-executive-index.csv'. " +
                                "Please make sure the file exists in the same directory.</p>";
                            return [];
                        })
                ]);
                
                console.log("CSV loading complete. Democracy data rows:", democracyData.length);
                console.log("CSV loading complete. Judicial data rows:", judicialData.length);
                
                if (!democracyData.length || !judicialData.length) {
                    throw new Error("One or both datasets are empty");
                }

                // Process democracy data
                const processedDemocracyData = democracyData.map(d => {
                    return {
                        country: d.countryname,
                        democracyIndex: parseFloat(d["Democracy index"])
                    };
                }).filter(d => !isNaN(d.democracyIndex));

                // Create a merged dataset
                const mergedData = [];
                
                judicialData.forEach(jd => {
                    const judicialConstraint = parseFloat(jd["Judicial constraints on the executive index (best estimate)"]);
                    
                    // Try to find a match in the democracy data
                    let countryName = jd.Entity;
                    // Check if the country name needs to be mapped
                    const mappedName = countryNameMapping[countryName];
                    
                    // Try with original name first, then with mapped name if available
                    let democracyMatch = processedDemocracyData.find(d => d.country === countryName);
                    
                    if (!democracyMatch && mappedName) {
                        democracyMatch = processedDemocracyData.find(d => d.country === mappedName);
                    }
                    
                    if (democracyMatch) {
                        mergedData.push({
                            country: countryName,
                            judicialConstraint: judicialConstraint,
                            democracyIndex: democracyMatch.democracyIndex
                        });
                    }
                });

                return mergedData;
            } catch (error) {
                console.error("Error loading or processing data:", error);
                document.getElementById("chart").innerHTML = "<p>Error loading data. Please make sure the CSV files exist.</p>";
                return [];
            }
        }

        // Create the 3D visualization
        loadData().then(data => {
            if (data.length === 0) return;
            
            // Create the 3D visualization
            const chartContainer = document.getElementById('chart');
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight || 600;

            // Define institutional mechanisms
            const mechanisms = [
                { name: 'judicial_constraints', color: '#e41a1c', displayName: 'Judicial Constraints' },
                { name: 'legislative_constraints', color: '#377eb8', displayName: 'Legislative Constraints' },
                { name: 'accountability_index', color: '#4daf4a', displayName: 'Accountability Index' },
                { name: 'high_court_independence', color: '#984ea3', displayName: 'High Court Independence' },
                { name: 'federalism_index', color: '#ff7f00', displayName: 'Federalism Index' }
            ];
            
            // Create fake institution data for testing until we integrate the real data
            const fakeInstitutionValues = {};
            data.forEach(d => {
                // Base probabilities on democracy index and judicial constraint values
                // More democratic countries are more likely to have more mechanisms
                const hasMechanism = (baseProb) => {
                    // Higher democracy index and judicial constraint increases probability
                    const adjustedProb = baseProb + 
                        (d.democracyIndex / 20) + // Up to +0.5 for democracy
                        (d.judicialConstraint / 2); // Up to +0.5 for judicial constraints
                    return Math.random() < adjustedProb;
                };
                
                // Certain mechanisms are more common in different types of regimes
                const values = {};
                
                // Judicial constraints - most countries have some form but strength varies
                if (hasMechanism(0.9)) {
                    values.judicial_constraints = 0.2 + Math.random() * 0.8 * d.judicialConstraint;
                }
                
                // Legislative constraints - common in democracies, rarer in authoritarian regimes
                if (hasMechanism(0.7)) {
                    values.legislative_constraints = 0.1 + Math.random() * 0.9 * d.judicialConstraint;
                }
                
                // Accountability index - varies widely
                if (hasMechanism(0.6)) {
                    values.accountability_index = 0.05 + Math.random() * 0.95 * d.democracyIndex / 10;
                }
                
                // High court independence - less common
                if (hasMechanism(0.5)) {
                    values.high_court_independence = Math.random() * d.judicialConstraint;
                }
                
                // Federalism - least common, exists in specific countries
                if (hasMechanism(0.3)) {
                    values.federalism_index = Math.random() * 0.9;
                }
                
                fakeInstitutionValues[d.country] = values;
            });
            
            // Add institution data to each country
            data.forEach(d => {
                const institutionValues = fakeInstitutionValues[d.country] || {};
                d.institutions = mechanisms.map(mech => {
                    // Only include mechanisms that exist for this country
                    const value = institutionValues[mech.name];
                    return {
                        name: mech.name,
                        displayName: mech.displayName,
                        color: mech.color,
                        value: value !== undefined ? value : null,
                        exists: value !== undefined
                    };
                });
            });
            
            // Initialize Three.js
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // Create an isometric camera view
            const aspectRatio = width / height;
            const camera = new THREE.OrthographicCamera(
                -5 * aspectRatio, 5 * aspectRatio, 5, -5, 0.1, 1000
            );
            
            // Position for isometric view (equidistant on all axes)
            camera.position.set(7, 7, 7);
            camera.lookAt(5, 0, 5);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            chartContainer.appendChild(renderer.domElement);

            // Add orbit controls for interaction (preserve isometric feel)
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Lock the camera to maintain isometric view
            controls.minZoom = 0.5;
            controls.maxZoom = 2;
            controls.enableRotate = true;
            controls.enablePan = true;
            
            // Set initial rotation to isometric angle
            controls.target.set(5, 0, 5); // Look at the center of the grid

            // Add tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Create axis labels
            function createTextSprite(text, position, color = 0x000000) {
                const sprite = new SpriteText(text);
                sprite.color = color;
                sprite.textHeight = 0.3;
                sprite.fontWeight = 'bold';
                sprite.position.copy(position);
                return sprite;
            }

            // Add grid and axes - creating custom grids that start from 0,0,0
            function createCustomGrid(size, divisions, color1, color2, plane = 'xz') {
                const material = new THREE.LineBasicMaterial({ color: color1 });
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                
                // Calculate step size
                const step = size / divisions;
                
                // Generate grid based on the specified plane
                if (plane === 'xz') {
                    // Floor grid (XZ plane)
                    for (let i = 0; i <= divisions; i++) {
                        const position = i * step;
                        // X lines
                        vertices.push(0, 0, position);
                        vertices.push(size, 0, position);
                        // Z lines
                        vertices.push(position, 0, 0);
                        vertices.push(position, 0, size);
                    }
                } else if (plane === 'xy') {
                    // Wall grid (XY plane at Z=0)
                    for (let i = 0; i <= divisions; i++) {
                        const position = i * step;
                        // X lines
                        vertices.push(0, position, 0);
                        vertices.push(size, position, 0);
                        // Y lines
                        vertices.push(position, 0, 0);
                        vertices.push(position, size, 0);
                    }
                } else if (plane === 'yz') {
                    // Side wall grid (YZ plane at X=0)
                    for (let i = 0; i <= divisions; i++) {
                        const position = i * step;
                        // Y lines
                        vertices.push(0, 0, position);
                        vertices.push(0, size, position);
                        // Z lines
                        vertices.push(0, position, 0);
                        vertices.push(0, position, size);
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                return new THREE.LineSegments(geometry, material);
            }
            
            // Create grids that start from 0,0,0
            const floorGrid = createCustomGrid(10, 10, 0xdddddd, 0xdddddd, 'xz');
            scene.add(floorGrid);
            
            const wallGridZ = createCustomGrid(10, 10, 0xe0e0e0, 0xe0e0e0, 'xy');
            scene.add(wallGridZ);
            
            const wallGridX = createCustomGrid(10, 10, 0xe0e0e0, 0xe0e0e0, 'yz');
            scene.add(wallGridX);

            // Add axis labels - positioned for corner-based grid
            scene.add(createTextSprite("Judicial Constraints", new THREE.Vector3(5, 0, -0.5)));
            scene.add(createTextSprite("Democracy Index", new THREE.Vector3(-0.5, 0, 5)));
            
            // Create a variable to track the institutional mechanisms label for visibility control
            const institutionalMechanismsLabel = createTextSprite("Institutional Mechanisms", new THREE.Vector3(-0.5, 5, -0.5));
            scene.add(institutionalMechanismsLabel);
            
            // Add axis markers with values - adjust for flipped Democracy Index
            for (let i = 0; i <= 10; i++) {
                // X-axis markers (Judicial Constraints)
                scene.add(createTextSprite((i/10).toFixed(1), new THREE.Vector3(i, -0.3, -0.3), 0x555555))
                    .textHeight = 0.2;
                
                // Z-axis markers (Democracy Index) - flipped values
                scene.add(createTextSprite((10-i).toString(), new THREE.Vector3(-0.3, -0.3, i), 0x555555))
                    .textHeight = 0.2;
            }

            // Add arrows for axes
            function createArrow(from, to, color = 0x666666) {
                const direction = new THREE.Vector3().subVectors(to, from).normalize();
                const arrowHelper = new THREE.ArrowHelper(
                    direction, 
                    from, 
                    to.distanceTo(from), 
                    color, 
                    0.3, // Head length
                    0.2  // Head width
                );
                return arrowHelper;
            }
            
            // Add arrows for clearer axes
            scene.add(createArrow(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(10.5, 0, 0)
            ));
            scene.add(createArrow(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 10.5, 0)
            ));
            scene.add(createArrow(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, 10.5)
            ));

            // Create cylindrical tubes for visualization
            const cylinderRadius = 0.15;
            const cylinderRadialSegments = 16;
            
            // Create materials for normal and highlighted points
            const defaultMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x3498db, 
                transparent: true, 
                opacity: 0.8 
            });
            const highlightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffc107, 
                transparent: true, 
                opacity: 0.9 
            });

            // Track meshes for interaction
            const allMeshes = [];
            const countryMeshes = {};

            // X and Z scales for positioning
            const xScale = d3.scaleLinear().domain([0, 1]).range([0, 10]);
            // Flip the Democracy Index scale so higher values are closer to the origin
            const zScale = d3.scaleLinear().domain([0, 10]).range([10, 0]);

            // Scale for tube height
            const heightScale = d3.scaleLinear().domain([0, 1]).range([0.2, 2]);

            // Add data points
            data.forEach(d => {
                // Map values directly to grid coordinates
                const x = xScale(d.judicialConstraint);
                const z = zScale(d.democracyIndex);
                
                // Base point for the country - a small disc
                const baseGeometry = new THREE.CylinderGeometry(
                    cylinderRadius, cylinderRadius, 0.05, cylinderRadialSegments
                );
                const baseMaterial = d.country === "Israel" ? highlightMaterial : defaultMaterial;
                const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
                baseMesh.position.set(x, 0.025, z); // Half height to position on ground
                baseMesh.userData = { 
                    country: d.country,
                    judicialConstraint: d.judicialConstraint,
                    democracyIndex: d.democracyIndex,
                    type: 'country'
                };
                scene.add(baseMesh);
                allMeshes.push(baseMesh);
                
                // Track meshes by country
                countryMeshes[d.country] = { base: baseMesh, mechanisms: [] };
                
                // Add mechanism tubes stacked on top of each other
                let currentHeight = 0.05; // Start at the top of the base disc
                
                d.institutions.forEach((inst, i) => {
                    // Only add tubes for mechanisms that exist for this country
                    if (inst.exists && inst.value !== null && !isNaN(inst.value)) {
                        // Calculate tube height based on mechanism value
                        const tubeHeight = heightScale(inst.value);
                        
                        const mechMaterial = new THREE.MeshBasicMaterial({ 
                            color: new THREE.Color(inst.color),
                            transparent: true,
                            opacity: 0.7
                        });
                        
                        // Create cylinder geometry for the tube
                        const tubeGeometry = new THREE.CylinderGeometry(
                            cylinderRadius, cylinderRadius, tubeHeight, cylinderRadialSegments
                        );
                        
                        const mechMesh = new THREE.Mesh(tubeGeometry, mechMaterial);
                        
                        // Position tube - center of the tube is at half its height
                        // We want the bottom of the tube at the current height
                        mechMesh.position.set(x, currentHeight + (tubeHeight / 2), z);
                        
                        mechMesh.userData = {
                            country: d.country,
                            mechanism: inst.displayName,
                            value: inst.value,
                            type: 'mechanism'
                        };
                        scene.add(mechMesh);
                        allMeshes.push(mechMesh);
                        countryMeshes[d.country].mechanisms.push(mechMesh);
                        
                        // Update the current height for the next tube
                        currentHeight += tubeHeight;
                    } else {
                        // Add a placeholder so the array indices stay consistent
                        countryMeshes[d.country].mechanisms.push(null);
                    }
                });
            });

            // Raycaster for mouse interaction
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            // Handle mouse move for tooltips
            function onMouseMove(event) {
                // Calculate mouse position in normalized device coordinates
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / height) * 2 + 1;
                
                // Update the raycaster
                raycaster.setFromCamera(mouse, camera);
                
                // Get intersected objects
                const intersects = raycaster.intersectObjects(allMeshes);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    const userData = object.userData;
                    
                    // Get country data for either country or mechanism point
                    const countryName = userData.country;
                    const countryData = data.find(d => d.country === countryName);
                    
                    if (countryData) {
                        tooltip.transition().duration(200).style("opacity", 0.95);
                        
                        // Build detailed tooltip content
                        let tooltipContent = `<strong>${countryData.country}</strong><br>`;
                        tooltipContent += `Democracy Index: <strong>${countryData.democracyIndex.toFixed(2)}</strong><br>`;
                        tooltipContent += `Judicial Constraints: <strong>${countryData.judicialConstraint.toFixed(2)}</strong><br><br>`;
                        
                        // Add institutional mechanisms section
                        tooltipContent += `<strong>Balancing Mechanisms:</strong><br>`;
                        
                        // Get existing mechanisms for this country
                        const existingMechanisms = countryData.institutions.filter(inst => inst.exists);
                        
                        if (existingMechanisms.length > 0) {
                            existingMechanisms.forEach(inst => {
                                const strengthLevel = getStrengthLevel(inst.value);
                                tooltipContent += `• ${inst.displayName}: <span style="color: ${getStrengthColor(strengthLevel)};">${strengthLevel}</span><br>`;
                            });
                            
                            // Add explanation based on mechanisms
                            tooltipContent += `<br><em>${generateExplanation(countryData)}</em>`;
                        } else {
                            tooltipContent += `<em>No significant institutional checks detected.</em>`;
                        }
                        
                        tooltip.html(tooltipContent)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px")
                            .style("max-width", "300px");
                    }
                } else {
                    tooltip.transition().duration(500).style("opacity", 0);
                }
            }
            
            // Function to determine mechanism strength level
            function getStrengthLevel(value) {
                if (value >= 0.8) return "Very Strong";
                if (value >= 0.6) return "Strong";
                if (value >= 0.4) return "Moderate";
                if (value >= 0.2) return "Weak";
                return "Very Weak";
            }
            
            // Function to get color for strength level
            function getStrengthColor(level) {
                switch(level) {
                    case "Very Strong": return "#1a9850";
                    case "Strong": return "#66bd63";
                    case "Moderate": return "#fdae61";
                    case "Weak": return "#f46d43";
                    case "Very Weak": return "#d73027";
                    default: return "#666666";
                }
            }
            
            // Function to generate explanation based on country's mechanisms
            function generateExplanation(countryData) {
                const existingMechanisms = countryData.institutions.filter(inst => inst.exists);
                const strongMechanisms = existingMechanisms.filter(m => m.value >= 0.6);
                const moderateMechanisms = existingMechanisms.filter(m => m.value >= 0.4 && m.value < 0.6);
                
                if (strongMechanisms.length >= 3) {
                    return `Power in ${countryData.country} is well-distributed with multiple strong institutional checks.`;
                } else if (strongMechanisms.length >= 1) {
                    const mechNames = strongMechanisms.map(m => m.displayName.toLowerCase()).join(" and ");
                    return `${countryData.country} relies primarily on ${mechNames} to balance government power.`;
                } else if (moderateMechanisms.length >= 2) {
                    return `${countryData.country} has several moderate institutional checks, but could benefit from strengthening them.`;
                } else if (existingMechanisms.length > 0) {
                    return `${countryData.country} has limited institutional mechanisms for balancing government power.`;
                } else {
                    return `${countryData.country} shows minimal checks on centralized power.`;
                }
            }
            
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);

            // Add checkbox event listeners
            mechanisms.forEach(mech => {
                document.getElementById(mech.name).addEventListener('change', function(e) {
                    const visible = e.target.checked;
                    
                    // Update visibility of all mechanism meshes of this type
                    data.forEach(d => {
                        const countryMeshGroup = countryMeshes[d.country];
                        if (countryMeshGroup) {
                            const index = mechanisms.findIndex(m => m.name === mech.name);
                            if (countryMeshGroup.mechanisms[index]) {
                                countryMeshGroup.mechanisms[index].visible = visible;
                            }
                        }
                    });
                });
            });

            // Render the scene
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                
                // Hide "Institutional Mechanisms" label when camera is viewing from above
                // Get normalized camera position vector
                const cameraPosition = camera.position.clone().normalize();
                // Check if camera's Y component is dominant (viewing from above)
                if (Math.abs(cameraPosition.y) > Math.max(Math.abs(cameraPosition.x), Math.abs(cameraPosition.z))) {
                    institutionalMechanismsLabel.visible = false;
                } else {
                    institutionalMechanismsLabel.visible = true;
                }
                
                renderer.render(scene, camera);
            }
            animate();

            // Create and populate the data table
            let currentSortColumn = null;
            let currentSortOrder = "asc";
            
            function renderTable(sortedData) {
                // Clear existing table
                d3.select("#data-table").html("");
                
                const table = d3.select("#data-table")
                    .append("table")
                    .attr("class", "data-table");
                
                // Add table header
                const thead = table.append("thead").append("tr");
                
                const columns = ["Country", "Democracy Index", "Judicial Constraints", "Power Distribution Index"];
                
                thead.selectAll("th")
                    .data(columns)
                    .enter()
                    .append("th")
                    .text(d => d)
                    .attr("class", d => {
                        if (d === currentSortColumn) {
                            return currentSortOrder;
                        }
                        return "";
                    })
                    .on("click", function(event, d) {
                        if (d === currentSortColumn) {
                            currentSortOrder = currentSortOrder === "asc" ? "desc" : "asc";
                        } else {
                            currentSortColumn = d;
                            currentSortOrder = "asc";
                        }
                        
                        // Sort the data
                        const sorted = [...data].sort((a, b) => {
                            let aVal, bVal;
                            
                            switch(d) {
                                case "Country":
                                    aVal = a.country;
                                    bVal = b.country;
                                    break;
                                case "Democracy Index":
                                    aVal = a.democracyIndex;
                                    bVal = b.democracyIndex;
                                    break;
                                case "Judicial Constraints":
                                    aVal = a.judicialConstraint;
                                    bVal = b.judicialConstraint;
                                    break;
                                case "Power Distribution Index":
                                    // Calculate power distribution index as average of all institution values
                                    // Only include mechanisms that exist
                                    aVal = a.institutions ? 
                                        a.institutions.filter(inst => inst.exists)
                                            .reduce((sum, inst) => sum + inst.value, 0) / 
                                        a.institutions.filter(inst => inst.exists).length : 0;
                                    bVal = b.institutions ? 
                                        b.institutions.filter(inst => inst.exists)
                                            .reduce((sum, inst) => sum + inst.value, 0) / 
                                        b.institutions.filter(inst => inst.exists).length : 0;
                                    break;
                            }
                            
                            if (currentSortOrder === "asc") {
                                return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                            } else {
                                return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                            }
                        });
                        
                        renderTable(sorted);
                    });
                
                // Add table body
                const tbody = table.append("tbody");
                
                // Add table rows
                tbody.selectAll("tr")
                    .data(sortedData)
                    .enter()
                    .append("tr")
                    .attr("class", d => d.country === "Israel" ? "israel" : "")
                    .selectAll("td")
                    .data(d => {
                        // Calculate power distribution index - only including mechanisms that exist
                        const existingMechanisms = d.institutions ? 
                            d.institutions.filter(inst => inst.exists) : [];
                        
                        const powerIndex = existingMechanisms.length > 0 ? 
                            existingMechanisms.reduce((sum, inst) => sum + inst.value, 0) / existingMechanisms.length : 0;
                        
                        return [
                            d.country,
                            d.democracyIndex.toFixed(2),
                            d.judicialConstraint.toFixed(2),
                            powerIndex.toFixed(2)
                        ];
                    })
                    .enter()
                    .append("td")
                    .text(d => d);
            }
            
            // Initial table render
            renderTable(data);

        }).catch(error => {
            console.error("Error creating chart:", error);
            document.getElementById("chart").innerHTML = "<p>Error creating chart. Please check the console for details.</p>";
        });
    </script>
</body>
</html>